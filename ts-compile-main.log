ready
{
  "serverFolderPath": "/Users/Sergey/Work/GH/typescript/node_modules/typescript/lib/",
  "pluginName": "typescript",
  "sessionId": "1486236505327",
  "hasManualParams": false
}
{
  "success": true,
  "message": {
    "version": "2.2.0-dev.20170124",
    "supportedErrorCodes": [
      "2304",
      "2377",
      "2420",
      "2515",
      "2653",
      "2686",
      "2689",
      "6133",
      "6138",
      "17009"
    ]
  }
}
{
  "success": true,
  "message": {
    "version": "2.2.0-dev.20170124",
    "supportedErrorCodes": [
      "2304",
      "2377",
      "2420",
      "2515",
      "2653",
      "2686",
      "2689",
      "6133",
      "6138",
      "17009"
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 0,
  "arguments": {
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "open"
}
{
  "seq": 0,
  "type": "response",
  "command": "open",
  "request_seq": 0,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 1,
  "arguments": {
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
  },
  "type": "request",
  "command": "open"
}
{
  "seq": 0,
  "type": "response",
  "command": "open",
  "request_seq": 1,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 2,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\n\n/*@internal*/\nnamespace ts {\n    export function transformSystemModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let exportFunction: Identifier; // The export function for the current file.\n        let contextObject: Identifier; // The context object for the current file.\n        let hoistedStatements: Statement[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            exportFunction = createUniqueName(\"exports\");\n            exportFunctionsMap[id] = exportFunction;\n            contextObject = createUniqueName(\"context\");\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, exportFunction),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, contextObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"System\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            exportFunction = undefined;\n            contextObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            \"__moduleName\",\n                            /*type*/ undefined,\n                            createLogicalAnd(\n                                contextObject,\n                                createPropertyAccess(contextObject, \"id\")\n                            )\n                        )\n                    ])\n                )\n            );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            exportFunction,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportFunction,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n\n            // Hoist the name of the class declaration to the outer module body function.\n            const name = getLocalName(node);\n            hoistVariableDeclaration(name);\n\n            // Rewrite the class declaration into an assignment of a class expression.\n            statements = append(statements,\n                createStatement(\n                    createAssignment(\n                        name,\n                        createClassExpression(\n                            /*modifiers*/ undefined,\n                            node.name,\n                            /*typeParameters*/ undefined,\n                            visitNodes(node.heritageClauses, destructuringVisitor, isHeritageClause),\n                            visitNodes(node.members, destructuringVisitor, isClassElement),\n                            /*location*/ node\n                        )\n                    ),\n                    /*location*/ node\n                )\n            );\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfHoistedDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportFunction, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                const externalHelpersModuleName = getExternalHelpersModuleName(currentSourceFile);\n                if (externalHelpersModuleName) {\n                    return createPropertyAccess(externalHelpersModuleName, node);\n                }\n                return node;\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n",
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to emit.\n         * @param emit A callback used to emit the node in the printer.\n         */\n        function onEmitNode(emitContext: EmitContext, node: Node, emitCallback: (emitContext: EmitContext, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                systemObject = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(emitContext, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                systemObject = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(emitContext, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 2,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 3,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 3,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 4,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 4,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 42
            },
            "end": {
              "line": 1544,
              "offset": 53
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1544,
              "offset": 95
            },
            "end": {
              "line": 1544,
              "offset": 106
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 5,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 5,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 6,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 6,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 42
            },
            "end": {
              "line": 1544,
              "offset": 53
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1544,
              "offset": 95
            },
            "end": {
              "line": 1544,
              "offset": 106
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 7,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 7,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 8,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 8,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 42
            },
            "end": {
              "line": 1544,
              "offset": 53
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1544,
              "offset": 95
            },
            "end": {
              "line": 1544,
              "offset": 106
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 9,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 9,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 42
            },
            "end": {
              "line": 1544,
              "offset": 53
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1544,
              "offset": 95
            },
            "end": {
              "line": 1544,
              "offset": 106
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 10,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 10,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 11,
  "arguments": {
    "startLine": 1544,
    "startOffset": 42,
    "endLine": 1544,
    "endOffset": 53,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 11,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 12,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emit A callback used to emit the node in the printer.\n         */\n        function onEmitNode(emitContext: EmitContext, node: Node, emitCallback: (emitContext: EmitContext, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                systemObject = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(emitContext, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                systemObject = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(emitContext, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 12,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 13,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 13,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 42
            },
            "end": {
              "line": 1544,
              "offset": 53
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1544,
              "offset": 95
            },
            "end": {
              "line": 1544,
              "offset": 106
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 14,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 14,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 15,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                systemObject = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(emitContext, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                systemObject = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(emitContext, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 15,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 16,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 16,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 29
            },
            "end": {
              "line": 1544,
              "offset": 33
            },
            "text": "TS6133:'hint' is declared but never used."
          },
          {
            "start": {
              "line": 1556,
              "offset": 36
            },
            "end": {
              "line": 1556,
              "offset": 47
            },
            "text": "TS2304:Cannot find name 'emitContext'."
          },
          {
            "start": {
              "line": 1564,
              "offset": 36
            },
            "end": {
              "line": 1564,
              "offset": 47
            },
            "text": "TS2304:Cannot find name 'emitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 17,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(emitContext, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                systemObject = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(emitContext, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 17,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 18,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 18,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1544,
              "offset": 29
            },
            "end": {
              "line": 1544,
              "offset": 33
            },
            "text": "TS6133:'hint' is declared but never used."
          },
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1556,
              "offset": 36
            },
            "end": {
              "line": 1556,
              "offset": 47
            },
            "text": "TS2304:Cannot find name 'emitContext'."
          },
          {
            "start": {
              "line": 1564,
              "offset": 36
            },
            "end": {
              "line": 1564,
              "offset": 47
            },
            "text": "TS2304:Cannot find name 'emitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 19,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 19,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 20,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(emitContext, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 20,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 21,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 21,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1564,
              "offset": 36
            },
            "end": {
              "line": 1564,
              "offset": 47
            },
            "text": "TS2304:Cannot find name 'emitContext'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 22,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param emitContext A context hint for the emitter.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 22,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 23,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 23,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 24,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 24,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 25,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(emitContext: EmitContext, node: Node) {\n            node = previousOnSubstituteNode(emitContext, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 25,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 26,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 26,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 27,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 27,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1578,
              "offset": 48
            },
            "end": {
              "line": 1578,
              "offset": 59
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 28,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (emitContext === EmitContext.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 28,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 29,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 29,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 17
            },
            "end": {
              "line": 1584,
              "offset": 28
            },
            "text": "TS2304:Cannot find name 'emitContext'."
          },
          {
            "start": {
              "line": 1584,
              "offset": 33
            },
            "end": {
              "line": 1584,
              "offset": 44
            },
            "text": "TS2304:Cannot find name 'EmitContext'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 30,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 30,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 31,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 31,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 32,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 32,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 33,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 33,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 34,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 34,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 35,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 35,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 36,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 36,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 37,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 37,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 38,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 38,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 39,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 39,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 40,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 40,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 41,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 41,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 42,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 42,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 43,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 43,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 44,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 44,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 45,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 45,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 46,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 46,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 47,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 47,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 48,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 48,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 49,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 49,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 50,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 50,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 51,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 51,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 52,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 52,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 53,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 53,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 54,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 54,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 55,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 55,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 56,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 56,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 57,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 57,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 58,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 58,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 59,
  "arguments": {
    "startLine": 1549,
    "startOffset": 17,
    "endLine": 1549,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 59,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 60,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 60,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 61,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 61,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 62,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 62,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 63,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 63,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 64,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 64,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 65,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 65,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 66,
  "arguments": {
    "startLine": 1549,
    "startOffset": 17,
    "endLine": 1549,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 66,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 67,
  "arguments": {
    "startLine": 1549,
    "startOffset": 17,
    "endLine": 1549,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 67,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 68,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 68,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 69,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                moduleObject = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 69,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 70,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 70,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 71,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 71,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 72,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                mod = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 72,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 73,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 73,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 74,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                exportFunction = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 74,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 75,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 75,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1549,
              "offset": 17
            },
            "end": {
              "line": 1549,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          },
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 76,
  "arguments": {
    "startLine": 1549,
    "startOffset": 17,
    "endLine": 1549,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 76,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 77,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                systemObject = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                exportFunction = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 77,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 78,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 78,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 79,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 79,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 80,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 80,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 81,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 81,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 82,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 82,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 83,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 83,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 84,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 84,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 85,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 85,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 86,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 86,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 87,
  "arguments": {
    "startLine": 1560,
    "startOffset": 17,
    "endLine": 1560,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 87,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 88,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 88,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 89,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 89,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 90,
  "arguments": {
    "startLine": 1560,
    "startOffset": 17,
    "endLine": 1560,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 90,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 91,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 91,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 92,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 92,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 93,
  "arguments": {
    "startLine": 1560,
    "startOffset": 17,
    "endLine": 1560,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 93,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 94,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 94,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 95,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 95,
  "success": true,
  "body": {
    "infos": [
      {
        "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts",
        "diagnostics": [
          {
            "start": {
              "line": 1560,
              "offset": 17
            },
            "end": {
              "line": 1560,
              "offset": 31
            },
            "text": "TS2304:Cannot find name 'exportFunction'."
          }
        ]
      }
    ]
  }
}
{
  "sessionId": 1486236505327,
  "seq": 96,
  "arguments": {
    "startLine": 1560,
    "startOffset": 17,
    "endLine": 1560,
    "endOffset": 31,
    "errorCodes": [
      2304
    ],
    "file": "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
  },
  "type": "request",
  "command": "getCodeFixes"
}
{
  "seq": 0,
  "type": "response",
  "command": "getCodeFixes",
  "request_seq": 96,
  "success": true,
  "body": []
}
{
  "sessionId": 1486236505327,
  "seq": 97,
  "arguments": {
    "files": {
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts": "/// <reference path=\"../../factory.ts\" />\n/// <reference path=\"../../visitor.ts\" />\ndeclare var console:any;\n/*@internal*/\nnamespace ts {\n    export function transformEcmalModule(context: TransformationContext) {\n        interface DependencyGroup {\n            name: StringLiteral;\n            externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n        }\n\n        const {\n            startLexicalEnvironment,\n            endLexicalEnvironment,\n            hoistVariableDeclaration\n        } = context;\n\n        const compilerOptions = context.getCompilerOptions();\n        const resolver = context.getEmitResolver();\n        const host = context.getEmitHost();\n        const previousOnSubstituteNode = context.onSubstituteNode;\n        const previousOnEmitNode = context.onEmitNode;\n        context.onSubstituteNode = onSubstituteNode;\n        context.onEmitNode = onEmitNode;\n        context.enableSubstitution(SyntaxKind.Identifier); // Substitutes expression identifiers for imported symbols.\n        context.enableSubstitution(SyntaxKind.BinaryExpression); // Substitutes assignments to exported symbols.\n        context.enableSubstitution(SyntaxKind.PrefixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableSubstitution(SyntaxKind.PostfixUnaryExpression); // Substitutes updates to exported symbols.\n        context.enableEmitNotification(SyntaxKind.SourceFile); // Restore state when substituting nodes in a file.\n\n        const moduleInfoMap: ExternalModuleInfo[] = []; // The ExternalModuleInfo for each file.\n        const deferredExports: Statement[][] = []; // Exports to defer until an EndOfDeclarationMarker is found.\n        const exportFunctionsMap: Identifier[] = []; // The export function associated with a source file.\n        const noSubstitutionMap: boolean[][] = []; // Set of nodes for which substitution rules should be ignored for each file.\n\n        let currentSourceFile: SourceFile; // The current file.\n        let moduleInfo: ExternalModuleInfo; // ExternalModuleInfo for the current file.\n        let systemObject: Identifier; // The export function for the current file.\n        let moduleObject: Identifier; // The context object for the current file.\n        let exportProperty: PropertyAccessExpression; // The export function for the current file.\n        let hoistedStatements: Statement[]=[];\n        let enclosingBlockScopedContainer: Node;\n        let noSubstitution: boolean[]; // Set of nodes for which substitution rules should be ignored.\n\n        return transformSourceFile;\n        \n        \n        function tryGetModuleNameFromFile(file: SourceFile, host: EmitHost, options: CompilerOptions): StringLiteral {\n            if (!file) {\n                return undefined;\n            }\n            if (file.moduleName) {\n                return createLiteral(file.moduleName);\n            }\n            if (!isDeclarationFile(file) && options) {\n                return createLiteral(getExternalModuleNameFromPath(host, file.fileName));\n            }\n            return undefined;\n        }\n\n        /**\n         * Transforms the module aspects of a SourceFile.\n         *\n         * @param node The SourceFile node.\n         */\n        function transformSourceFile(node: SourceFile) {\n            if (isDeclarationFile(node)\n                || !(isExternalModule(node)\n                    || compilerOptions.isolatedModules)) {\n                return node;\n            }\n\n            const id = getOriginalNodeId(node);\n            currentSourceFile = node;\n            enclosingBlockScopedContainer = node;\n\n            // System modules have the following shape:\n            //\n            //     System.register(['dep-1', ... 'dep-n'], function(exports) {/* module body function */})\n            //\n            // The parameter 'exports' here is a callback '<T>(name: string, value: T) => T' that\n            // is used to publish exported values. 'exports' returns its 'value' argument so in\n            // most cases expressions that mutate exported values can be rewritten as:\n            //\n            //     expr -> exports('name', expr)\n            //\n            // The only exception in this rule is postfix unary operators,\n            // see comment to 'substitutePostfixUnaryExpression' for more details\n\n            // Collect information about the external module and dependency groups.\n            moduleInfo = moduleInfoMap[id] = collectExternalModuleInfo(node, resolver, compilerOptions);\n\n            // Make sure that the name of the 'exports' function does not conflict with\n            // existing identifiers.\n            systemObject = createIdentifier(\"system\");\n            exportFunctionsMap[id] = systemObject;\n            moduleObject = createIdentifier(\"module\");\n            exportProperty = createPropertyAccess(moduleObject,createIdentifier(\"__export\"));\n\n            // Add the body of the module.\n            const dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);\n            const moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);\n            const moduleBodyFunction = createFunctionExpression(\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                /*name*/ undefined,\n                /*typeParameters*/ undefined,\n                [\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, systemObject),\n                    createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, moduleObject)\n                ],\n                /*type*/ undefined,\n                moduleBodyBlock\n            );\n\n            // Write the call to `System.register`\n            // Clear the emit-helpers flag for later passes since we'll have already used it in the module body\n            // So the helper will be emit at the correct position instead of at the top of the source-file\n            const moduleName = tryGetModuleNameFromFile(node, host, compilerOptions);\n            const dependencies = createArrayLiteral(map(dependencyGroups, dependencyGroup => dependencyGroup.name));\n            const updated = setEmitFlags(\n                updateSourceFileNode(\n                    node,\n                    createNodeArray([\n                        createStatement(\n                            createCall(\n                                createPropertyAccess(createIdentifier(\"system\"), \"register\"),\n                            /*typeArguments*/ undefined,\n                                moduleName\n                                    ? [moduleName, dependencies, moduleBodyFunction]\n                                    : [dependencies, moduleBodyFunction]\n                            )\n                        )\n                    ], node.statements)\n                ), EmitFlags.NoTrailingComments);\n\n            if (!(compilerOptions.outFile || compilerOptions.out)) {\n                moveEmitHelpers(updated, moduleBodyBlock, helper => !helper.scoped);\n            }\n\n            if (noSubstitution) {\n                noSubstitutionMap[id] = noSubstitution;\n                noSubstitution = undefined;\n            }\n\n            currentSourceFile = undefined;\n            moduleInfo = undefined;\n            systemObject = undefined;\n            moduleObject = undefined;\n            hoistedStatements = undefined;\n            enclosingBlockScopedContainer = undefined;\n\n            return aggregateTransformFlags(updated);\n        }\n\n        /**\n         * Collects the dependency groups for this files imports.\n         *\n         * @param externalImports The imports for the file.\n         */\n        function collectDependencyGroups(externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[]) {\n            const groupIndices = createMap<number>();\n            const dependencyGroups: DependencyGroup[] = [];\n            for (let i = 0; i < externalImports.length; i++) {\n                const externalImport = externalImports[i];\n                const externalModuleName = getExternalModuleNameLiteral(externalImport, currentSourceFile, host, resolver, compilerOptions);\n                const text = externalModuleName.text;\n                const groupIndex = groupIndices.get(text);\n                if (groupIndex !== undefined) {\n                    // deduplicate/group entries in dependency list by the dependency name\n                    dependencyGroups[groupIndex].externalImports.push(externalImport);\n                }\n                else {\n                    groupIndices.set(text, dependencyGroups.length);\n                    dependencyGroups.push({\n                        name: externalModuleName,\n                        externalImports: [externalImport]\n                    });\n                }\n            }\n\n            return dependencyGroups;\n        }\n\n        /**\n         * Adds the statements for the module body function for the source file.\n         *\n         * @param node The source file for the module.\n         * @param dependencyGroups The grouped dependencies of the module.\n         */\n        function createSystemModuleBody(node: SourceFile, dependencyGroups: DependencyGroup[]) {\n            // Shape of the body in system modules:\n            //\n            //  function (exports) {\n            //      <list of local aliases for imports>\n            //      <hoisted variable declarations>\n            //      <hoisted function declarations>\n            //      return {\n            //          setters: [\n            //              <list of setter function for imports>\n            //          ],\n            //          execute: function() {\n            //              <module statements>\n            //          }\n            //      }\n            //      <temp declarations>\n            //  }\n            //\n            // i.e:\n            //\n            //   import {x} from 'file1'\n            //   var y = 1;\n            //   export function foo() { return y + x(); }\n            //   console.log(y);\n            //\n            // Will be transformed to:\n            //\n            //  function(exports) {\n            //      function foo() { return y + file_1.x(); }\n            //      exports(\"foo\", foo);\n            //      var file_1, y;\n            //      return {\n            //          setters: [\n            //              function(v) { file_1 = v }\n            //          ],\n            //          execute(): function() {\n            //              y = 1;\n            //              console.log(y);\n            //          }\n            //      };\n            //  }\n\n            const statements: Statement[] = [];\n\n            // We start a new lexical environment in this function body, but *not* in the\n            // body of the execute function. This allows us to emit temporary declarations\n            // only in the outer module body and not in the inner one.\n            startLexicalEnvironment();\n\n            // Add any prologue directives.\n            const statementOffset = addPrologueDirectives(statements, node.statements, /*ensureUseStrict*/ !compilerOptions.noImplicitUseStrict, sourceElementVisitor);\n\n            // var __moduleName = context_1 && context_1.id;\n            // statements.push(\n            //     createVariableStatement(\n            //         /*modifiers*/ undefined,\n            //         createVariableDeclarationList([\n            //             createVariableDeclaration(\n            //                 \"__moduleName\",\n            //                 /*type*/ undefined,\n            //                 createLogicalAnd(\n            //                     moduleObject,\n            //                     createPropertyAccess(moduleObject, \"id\")\n            //                 )\n            //             )\n            //         ])\n            //     )\n            // );\n\n            // Visit the synthetic external helpers import declaration if present\n            visitNode(moduleInfo.externalHelpersImportDeclaration, sourceElementVisitor, isStatement, /*optional*/ true);\n\n            // Visit the statements of the source file, emitting any transformations into\n            // the `executeStatements` array. We do this *before* we fill the `setters` array\n            // as we both emit transformations as well as aggregate some data used when creating\n            // setters. This allows us to reduce the number of times we need to loop through the\n            // statements of the source file.\n            const executeStatements = visitNodes(node.statements, sourceElementVisitor, isStatement, statementOffset);\n\n            // We emit hoisted variables early to align roughly with our previous emit output.\n            // Two key differences in this approach are:\n            // - Temporary variables will appear at the top rather than at the bottom of the file\n            addRange(statements, endLexicalEnvironment());\n\n            // Emit early exports for function declarations.\n            addRange(statements, hoistedStatements);\n\n\n\n            const exportStarFunction = addExportStarIfNeeded(statements);\n            statements.push(\n                createReturn(\n                    setMultiLine(\n                        createObjectLiteral([\n                            createPropertyAssignment(\"setters\",\n                                createSettersArray(exportStarFunction, dependencyGroups)\n                            ),\n                            createPropertyAssignment(\"execute\",\n                                createFunctionExpression(\n                                    /*modifiers*/ undefined,\n                                    /*asteriskToken*/ undefined,\n                                    /*name*/ undefined,\n                                    /*typeParameters*/ undefined,\n                                    /*parameters*/ [],\n                                    /*type*/ undefined,\n                                    createBlock(\n                                        executeStatements,\n                                        /*location*/ undefined,\n                                        /*multiLine*/ true\n                                    )\n                                )\n                            )\n                        ]),\n                        /*multiLine*/ true\n                    )\n                )\n            );\n\n            return createBlock(statements, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        /**\n         * Adds an exportStar function to a statement list if it is needed for the file.\n         *\n         * @param statements A statement list.\n         */\n        function addExportStarIfNeeded(statements: Statement[]) {\n            if (!moduleInfo.hasExportStarsToExportValues) {\n                return;\n            }\n\n            // when resolving exports local exported entries/indirect exported entries in the module\n            // should always win over entries with similar names that were added via star exports\n            // to support this we store names of local/indirect exported entries in a set.\n            // this set is used to filter names brought by star expors.\n\n            // local names set should only be added if we have anything exported\n            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {\n                // no exported declarations (export var ...) or export specifiers (export {x})\n                // check if we have any non star export declarations.\n                let hasExportDeclarationWithExportClause = false;\n                for (const externalImport of moduleInfo.externalImports) {\n                    if (externalImport.kind === SyntaxKind.ExportDeclaration && externalImport.exportClause) {\n                        hasExportDeclarationWithExportClause = true;\n                        break;\n                    }\n                }\n\n                if (!hasExportDeclarationWithExportClause) {\n                    // we still need to emit exportStar helper\n                    const exportStarFunction = createExportStarFunction(/*localNames*/ undefined);\n                    statements.push(exportStarFunction);\n                    return exportStarFunction.name;\n                }\n            }\n\n            const exportedNames: ObjectLiteralElementLike[] = [];\n            if (moduleInfo.exportedNames) {\n                for (const exportedLocalName of moduleInfo.exportedNames) {\n                    if (exportedLocalName.text === \"default\") {\n                        continue;\n                    }\n\n                    // write name of exported declaration, i.e 'export var x...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral(exportedLocalName),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            for (const externalImport of moduleInfo.externalImports) {\n                if (externalImport.kind !== SyntaxKind.ExportDeclaration) {\n                    continue;\n                }\n\n                const exportDecl = <ExportDeclaration>externalImport;\n                if (!exportDecl.exportClause) {\n                    // export * from ...\n                    continue;\n                }\n\n                for (const element of exportDecl.exportClause.elements) {\n                    // write name of indirectly exported entry, i.e. 'export {x} from ...'\n                    exportedNames.push(\n                        createPropertyAssignment(\n                            createLiteral((element.name || element.propertyName).text),\n                            createLiteral(true)\n                        )\n                    );\n                }\n            }\n\n            const exportedNamesStorageRef = createUniqueName(\"exportedNames\");\n            statements.push(\n                createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList([\n                        createVariableDeclaration(\n                            exportedNamesStorageRef,\n                            /*type*/ undefined,\n                            createObjectLiteral(exportedNames, /*location*/ undefined, /*multiline*/ true)\n                        )\n                    ])\n                )\n            );\n\n            const exportStarFunction = createExportStarFunction(exportedNamesStorageRef);\n            statements.push(exportStarFunction);\n            return exportStarFunction.name;\n        }\n\n        /**\n         * Creates an exportStar function for the file, with an optional set of excluded local\n         * names.\n         *\n         * @param localNames An optional reference to an object containing a set of excluded local\n         * names.\n         */\n        function createExportStarFunction(localNames: Identifier | undefined) {\n            const exportStarFunction = createUniqueName(\"exportStar\");\n            const m = createIdentifier(\"m\");\n            const n = createIdentifier(\"n\");\n            const exports = createIdentifier(\"exports\");\n            let condition: Expression = createStrictInequality(n, createLiteral(\"default\"));\n            if (localNames) {\n                condition = createLogicalAnd(\n                    condition,\n                    createLogicalNot(\n                        createCall(\n                            createPropertyAccess(localNames, \"hasOwnProperty\"),\n                            /*typeArguments*/ undefined,\n                            [n]\n                        )\n                    )\n                );\n            }\n\n            return createFunctionDeclaration(\n                /*decorators*/ undefined,\n                /*modifiers*/ undefined,\n                /*asteriskToken*/ undefined,\n                exportStarFunction,\n                /*typeParameters*/ undefined,\n                [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, m)],\n                /*type*/ undefined,\n                createBlock([\n                    createVariableStatement(\n                        /*modifiers*/ undefined,\n                        createVariableDeclarationList([\n                            createVariableDeclaration(\n                                exports,\n                                /*type*/ undefined,\n                                createObjectLiteral([])\n                            )\n                        ])\n                    ),\n                    createForIn(\n                        createVariableDeclarationList([\n                            createVariableDeclaration(n, /*type*/ undefined)\n                        ]),\n                        m,\n                        createBlock([\n                            setEmitFlags(\n                                createIf(\n                                    condition,\n                                    createStatement(\n                                        createAssignment(\n                                            createElementAccess(exports, n),\n                                            createElementAccess(m, n)\n                                        )\n                                    )\n                                ),\n                                EmitFlags.SingleLine\n                            )\n                        ])\n                    ),\n                    createStatement(\n                        createCall(\n                            systemObject,\n                            /*typeArguments*/ undefined,\n                            [exports]\n                        )\n                    )\n                ],\n                /*location*/ undefined,\n                /*multiline*/ true)\n            );\n        }\n\n        /**\n         * Creates an array setter callbacks for each dependency group.\n         *\n         * @param exportStarFunction A reference to an exportStarFunction for the file.\n         * @param dependencyGroups An array of grouped dependencies.\n         */\n        function createSettersArray(exportStarFunction: Identifier, dependencyGroups: DependencyGroup[]) {\n            const setters: Expression[] = [];\n            for (const group of dependencyGroups) {\n                // derive a unique name for parameter from the first named entry in the group\n                const localName = forEach(group.externalImports, i => getLocalNameForExternalImport(i, currentSourceFile));\n                const parameterName = localName ? getGeneratedNameForNode(localName) : createUniqueName(\"\");\n                const statements: Statement[] = [];\n                for (const entry of group.externalImports) {\n                    const importVariableName = getLocalNameForExternalImport(entry, currentSourceFile);\n                    switch (entry.kind) {\n                        case SyntaxKind.ImportDeclaration:\n                            if (!(<ImportDeclaration>entry).importClause) {\n                                // 'import \"...\"' case\n                                // module is imported only for side-effects, no emit required\n                                break;\n                            }\n\n                        // fall-through\n                        case SyntaxKind.ImportEqualsDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            // save import into the local\n                            statements.push(\n                                createStatement(\n                                    createAssignment(importVariableName, parameterName)\n                                )\n                            );\n                            break;\n\n                        case SyntaxKind.ExportDeclaration:\n                            Debug.assert(importVariableName !== undefined);\n                            if ((<ExportDeclaration>entry).exportClause) {\n                                //  export {a, b as c} from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exports_({\n                                //     \"a\": _[\"a\"],\n                                //     \"c\": _[\"b\"]\n                                //  });\n                                const properties: PropertyAssignment[] = [];\n                                for (const e of (<ExportDeclaration>entry).exportClause.elements) {\n                                    properties.push(\n                                        createPropertyAssignment(\n                                            createLiteral(e.name.text),\n                                            createElementAccess(\n                                                parameterName,\n                                                createLiteral((e.propertyName || e.name).text)\n                                            )\n                                        )\n                                    );\n                                }\n\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportProperty,\n                                            /*typeArguments*/ undefined,\n                                            [createObjectLiteral(properties, /*location*/ undefined, /*multiline*/ true)]\n                                        )\n                                    )\n                                );\n                            }\n                            else {\n                                //  export * from 'foo'\n                                //\n                                // emit as:\n                                //\n                                //  exportStar(foo_1_1);\n                                statements.push(\n                                    createStatement(\n                                        createCall(\n                                            exportStarFunction,\n                                            /*typeArguments*/ undefined,\n                                            [parameterName]\n                                        )\n                                    )\n                                );\n                            }\n                            break;\n                    }\n                }\n\n                setters.push(\n                    createFunctionExpression(\n                        /*modifiers*/ undefined,\n                        /*asteriskToken*/ undefined,\n                        /*name*/ undefined,\n                        /*typeParameters*/ undefined,\n                        [createParameter(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)],\n                        /*type*/ undefined,\n                        createBlock(statements, /*location*/ undefined, /*multiLine*/ true)\n                    )\n                );\n            }\n\n            return createArrayLiteral(setters, /*location*/ undefined, /*multiLine*/ true);\n        }\n\n        //\n        // Top-level Source Element Visitors\n        //\n\n        /**\n         * Visit source elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function sourceElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ImportDeclaration:\n                    return visitImportDeclaration(<ImportDeclaration>node);\n\n                case SyntaxKind.ImportEqualsDeclaration:\n                    return visitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n\n                case SyntaxKind.ExportDeclaration:\n                    // ExportDeclarations are elided as they are handled via\n                    // `appendExportsOfDeclaration`.\n                    return undefined;\n\n                case SyntaxKind.ExportAssignment:\n                    return visitExportAssignment(<ExportAssignment>node);\n\n                default:\n                    return nestedElementVisitor(node);\n            }\n        }\n\n        /**\n         * Visits an ImportDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportDeclaration(node: ImportDeclaration): VisitResult<Statement> {\n            let statements: Statement[];\n            if (node.importClause) {\n                hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ImportEqualsDeclaration node.\n         *\n         * @param node The node to visit.\n         */\n        function visitImportEqualsDeclaration(node: ImportEqualsDeclaration): VisitResult<Statement> {\n            Debug.assert(isExternalModuleImportEqualsDeclaration(node), \"import= for internal module references should be handled in an earlier transformer.\");\n\n            let statements: Statement[];\n            hoistVariableDeclaration(getLocalNameForExternalImport(node, currentSourceFile));\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);\n            }\n            else {\n                statements = appendExportsOfImportEqualsDeclaration(statements, node);\n            }\n\n            return singleOrMany(statements);\n        }\n\n        /**\n         * Visits an ExportAssignment node.\n         *\n         * @param node The node to visit.\n         */\n        function visitExportAssignment(node: ExportAssignment): VisitResult<Statement> {\n            if (node.isExportEquals) {\n                // Elide `export=` as it is illegal in a SystemJS module.\n                return undefined;\n            }\n\n            const expression = visitNode(node.expression, destructuringVisitor, isExpression);\n            const original = node.original;\n            if (original && hasAssociatedEndOfDeclarationMarker(original)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportStatement(deferredExports[id], createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n            else {\n                return createExportStatement(createIdentifier(\"default\"), expression, /*allowComments*/ true);\n            }\n        }\n\n        /**\n         * Visits a FunctionDeclaration, hoisting it to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitFunctionDeclaration(node: FunctionDeclaration): VisitResult<Statement> {\n            if (hasModifier(node, ModifierFlags.Export)) {\n                hoistedStatements = append(hoistedStatements,\n                    updateFunctionDeclaration(\n                        node,\n                        node.decorators,\n                        visitNodes(node.modifiers, modifierVisitor, isModifier),\n                        getDeclarationName(node, /*allowComments*/ true, /*allowSourceMaps*/ true),\n                        /*typeParameters*/ undefined,\n                        visitNodes(node.parameters, destructuringVisitor, isParameterDeclaration),\n                        /*type*/ undefined,\n                        visitNode(node.body, destructuringVisitor, isBlock)));\n            }\n            else {\n                hoistedStatements = append(hoistedStatements, node);\n            }\n\n            if (hasAssociatedEndOfDeclarationMarker(node)) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);\n            }\n            else {\n                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);\n            }\n\n            return undefined;\n        }\n\n        /**\n         * Visits a ClassDeclaration, hoisting its name to the outer module body function.\n         *\n         * @param node The node to visit.\n         */\n        function visitClassDeclaration(node: ClassDeclaration): VisitResult<Statement> {\n            hoistedStatements = append(hoistedStatements,node);\n            return undefined;\n        }\n\n        /**\n         * Visits a variable statement, hoisting declared names to the top-level module body.\n         * Each declaration is rewritten into an assignment expression.\n         *\n         * @param node The node to visit.\n         */\n        function visitVariableStatement(node: VariableStatement): VisitResult<Statement> {\n            if (!shouldHoistVariableDeclarationList(node.declarationList)) {\n                return visitNode(node, destructuringVisitor, isStatement);\n            }\n\n            let expressions: Expression[];\n            const isExportedDeclaration = hasModifier(node, ModifierFlags.Export);\n            const isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);\n            for (const variable of node.declarationList.declarations) {\n                if (variable.initializer) {\n                    expressions = append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));\n                }\n                else {\n                    hoistBindingElement(variable);\n                }\n            }\n\n            let statements: Statement[];\n            if (expressions) {\n                statements = append(statements, createStatement(inlineExpressions(expressions), /*location*/ node));\n            }\n\n            if (isMarkedDeclaration) {\n                // Defer exports until we encounter an EndOfDeclarationMarker node\n                const id = getOriginalNodeId(node);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);\n            }\n            else {\n                statements = appendExportsOfVariableStatement(statements, node, /*exportSelf*/ false);\n            }\n            \n            \n\n           \n            return singleOrMany(statements);           \n        }\n\n        /**\n         * Hoists the declared names of a VariableDeclaration or BindingElement.\n         *\n         * @param node The declaration to hoist.\n         */\n        function hoistBindingElement(node: VariableDeclaration | BindingElement): void {\n            if (isBindingPattern(node.name)) {\n                for (const element of node.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        hoistBindingElement(element);\n                    }\n                }\n            }\n            else {\n                hoistVariableDeclaration(getSynthesizedClone(node.name));\n            }\n        }\n\n        /**\n         * Determines whether a VariableDeclarationList should be hoisted.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistVariableDeclarationList(node: VariableDeclarationList) {\n            // hoist only non-block scoped declarations or block scoped declarations parented by source file\n            return (getEmitFlags(node) & EmitFlags.NoHoisting) === 0\n                && (enclosingBlockScopedContainer.kind === SyntaxKind.SourceFile\n                    || (getOriginalNode(node).flags & NodeFlags.BlockScoped) === 0);\n        }\n\n        /**\n         * Transform an initialized variable declaration into an expression.\n         *\n         * @param node The node to transform.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function transformInitializedVariable(node: VariableDeclaration, isExportedDeclaration: boolean): Expression {\n            const createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;\n            return isBindingPattern(node.name)\n                ? flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ false,\n                    createAssignment\n                )\n                : createAssignment(node.name, visitNode(node.initializer, destructuringVisitor, isExpression));\n        }\n\n        /**\n         * Creates an assignment expression for an exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ true);\n        }\n\n        /**\n         * Creates an assignment expression for a non-exported variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         */\n        function createNonExportedVariableAssignment(name: Identifier, value: Expression, location?: TextRange) {\n            return createVariableAssignment(name, value, location, /*isExportedDeclaration*/ false);\n        }\n\n        /**\n         * Creates an assignment expression for a variable declaration.\n         *\n         * @param name The name of the variable.\n         * @param value The value of the variable's initializer.\n         * @param location The source map location for the assignment.\n         * @param isExportedDeclaration A value indicating whether the variable is exported.\n         */\n        function createVariableAssignment(name: Identifier, value: Expression, location: TextRange, isExportedDeclaration: boolean) {\n            hoistVariableDeclaration(getSynthesizedClone(name));\n            return isExportedDeclaration\n                ? createExportExpression(name, preventSubstitution(createAssignment(name, value, location)))\n                : preventSubstitution(createAssignment(name, value, location));\n        }\n\n        /**\n         * Visits a MergeDeclarationMarker used as a placeholder for the beginning of a merged\n         * and transformed declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitMergeDeclarationMarker(node: MergeDeclarationMarker): VisitResult<Statement> {\n            // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding\n            // declaration we do not emit a leading variable declaration. To preserve the\n            // begin/end semantics of the declararation and to properly handle exports\n            // we wrapped the leading variable declaration in a `MergeDeclarationMarker`.\n            //\n            // To balance the declaration, we defer the exports of the elided variable\n            // statement until we visit this declaration's `EndOfDeclarationMarker`.\n            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === SyntaxKind.VariableStatement) {\n                const id = getOriginalNodeId(node);\n                const isExportedDeclaration = hasModifier(node.original, ModifierFlags.Export);\n                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], <VariableStatement>node.original, isExportedDeclaration);\n            }\n\n            return node;\n        }\n\n        /**\n         * Determines whether a node has an associated EndOfDeclarationMarker.\n         *\n         * @param node The node to test.\n         */\n        function hasAssociatedEndOfDeclarationMarker(node: Node) {\n            return (getEmitFlags(node) & EmitFlags.HasEndOfDeclarationMarker) !== 0;\n        }\n\n        /**\n         * Visits a DeclarationMarker used as a placeholder for the end of a transformed\n         * declaration.\n         *\n         * @param node The node to visit.\n         */\n        function visitEndOfDeclarationMarker(node: EndOfDeclarationMarker): VisitResult<Statement> {\n            // For some transformations we emit an `EndOfDeclarationMarker` to mark the actual\n            // end of the transformed declaration. We use this marker to emit any deferred exports\n            // of the declaration.\n            const id = getOriginalNodeId(node);\n            const statements = deferredExports[id];\n            if (statements) {\n                delete deferredExports[id];\n                return append(statements, node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Appends the exports of an ImportDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportDeclaration(statements: Statement[], decl: ImportDeclaration) {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const importClause = decl.importClause;\n            if (!importClause) {\n                return statements;\n            }\n\n            if (importClause.name) {\n                statements = appendExportsOfDeclaration(statements, importClause);\n            }\n\n            const namedBindings = importClause.namedBindings;\n            if (namedBindings) {\n                switch (namedBindings.kind) {\n                    case SyntaxKind.NamespaceImport:\n                        statements = appendExportsOfDeclaration(statements, namedBindings);\n                        break;\n\n                    case SyntaxKind.NamedImports:\n                        for (const importBinding of namedBindings.elements) {\n                            statements = appendExportsOfDeclaration(statements, importBinding);\n                        }\n\n                        break;\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the export of an ImportEqualsDeclaration to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfImportEqualsDeclaration(statements: Statement[], decl: ImportEqualsDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            return appendExportsOfDeclaration(statements, decl);\n        }\n\n        /**\n         * Appends the exports of a VariableStatement to a statement list, returning the statement\n         * list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param node The VariableStatement whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export each VariableDeclaration of\n         * `nodes` declaration list.\n         */\n        function appendExportsOfVariableStatement(statements: Statement[] | undefined, node: VariableStatement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            for (const decl of node.declarationList.declarations) {\n                if (decl.initializer || exportSelf) {\n                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);\n                }\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a VariableDeclaration or BindingElement to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         * @param exportSelf A value indicating whether to also export the declaration itself.\n         */\n        function appendExportsOfBindingElement(statements: Statement[] | undefined, decl: VariableDeclaration | BindingElement, exportSelf: boolean): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            if (isBindingPattern(decl.name)) {\n                for (const element of decl.name.elements) {\n                    if (!isOmittedExpression(element)) {\n                        statements = appendExportsOfBindingElement(statements, element, exportSelf);\n                    }\n                }\n            }\n            else if (!isGeneratedIdentifier(decl.name)) {\n                let excludeName: string;\n                if (exportSelf) {\n                    statements = appendExportStatement(statements, decl.name, getLocalName(decl));\n                    excludeName = decl.name.text;\n                }\n\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a ClassDeclaration or FunctionDeclaration to a statement list,\n         * returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration whose exports are to be recorded.\n         */\n        function appendExportsOfHoistedDeclaration(statements: Statement[] | undefined, decl: ClassDeclaration | FunctionDeclaration): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            let excludeName: string;\n            if (hasModifier(decl, ModifierFlags.Export)) {\n                const exportName = hasModifier(decl, ModifierFlags.Default) ? createLiteral(\"default\") : decl.name;\n                statements = appendExportStatement(statements, exportName, getLocalName(decl));\n                excludeName = exportName.text;\n            }\n\n            if (decl.name) {\n                statements = appendExportsOfDeclaration(statements, decl, excludeName);\n            }\n\n            return statements;\n        }\n\n        /**\n         * Appends the exports of a declaration to a statement list, returning the statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param decl The declaration to export.\n         * @param excludeName An optional name to exclude from exports.\n         */\n        function appendExportsOfDeclaration(statements: Statement[] | undefined, decl: Declaration, excludeName?: string): Statement[] | undefined {\n            if (moduleInfo.exportEquals) {\n                return statements;\n            }\n\n            const name = getDeclarationName(decl);\n            const exportSpecifiers = moduleInfo.exportSpecifiers.get(name.text);\n            if (exportSpecifiers) {\n                for (const exportSpecifier of exportSpecifiers) {\n                    if (exportSpecifier.name.text !== excludeName) {\n                        statements = appendExportStatement(statements, exportSpecifier.name, name);\n                    }\n                }\n            }\n            return statements;\n        }\n\n        /**\n         * Appends the down-level representation of an export to a statement list, returning the\n         * statement list.\n         *\n         * @param statements A statement list to which the down-level export statements are to be\n         * appended. If `statements` is `undefined`, a new array is allocated if statements are\n         * appended.\n         * @param exportName The name of the export.\n         * @param expression The expression to export.\n         * @param allowComments Whether to allow comments on the export.\n         */\n        function appendExportStatement(statements: Statement[] | undefined, exportName: Identifier | StringLiteral, expression: Expression, allowComments?: boolean): Statement[] | undefined {\n            statements = append(statements, createExportStatement(exportName, expression, allowComments));\n            return statements;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         * @param allowComments An optional value indicating whether to emit comments for the statement.\n         */\n        function createExportStatement(name: Identifier | StringLiteral, value: Expression, allowComments?: boolean) {\n            const statement = createStatement(createExportExpression(name, value));\n            startOnNewLine(statement);\n            if (!allowComments) {\n                setEmitFlags(statement, EmitFlags.NoComments);\n            }\n\n            return statement;\n        }\n\n        /**\n         * Creates a call to the current file's export function to export a value.\n         *\n         * @param name The bound name of the export.\n         * @param value The exported value.\n         */\n        function createExportExpression(name: Identifier | StringLiteral, value: Expression) {\n            const exportName = isIdentifier(name) ? createLiteral(name) : name;\n            return createCall(exportProperty, /*typeArguments*/ undefined, [exportName, value]);\n        }\n\n        //\n        // Top-Level or Nested Source Element Visitors\n        //\n\n        /**\n         * Visit nested elements at the top-level of a module.\n         *\n         * @param node The node to visit.\n         */\n        function nestedElementVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    return visitVariableStatement(<VariableStatement>node);\n\n                case SyntaxKind.FunctionDeclaration:\n                    return visitFunctionDeclaration(<FunctionDeclaration>node);\n\n                case SyntaxKind.ClassDeclaration:\n                    return visitClassDeclaration(<ClassDeclaration>node);\n\n                case SyntaxKind.ForStatement:\n                    return visitForStatement(<ForStatement>node);\n\n                case SyntaxKind.ForInStatement:\n                    return visitForInStatement(<ForInStatement>node);\n\n                case SyntaxKind.ForOfStatement:\n                    return visitForOfStatement(<ForOfStatement>node);\n\n                case SyntaxKind.DoStatement:\n                    return visitDoStatement(<DoStatement>node);\n\n                case SyntaxKind.WhileStatement:\n                    return visitWhileStatement(<WhileStatement>node);\n\n                case SyntaxKind.LabeledStatement:\n                    return visitLabeledStatement(<LabeledStatement>node);\n\n                case SyntaxKind.WithStatement:\n                    return visitWithStatement(<WithStatement>node);\n\n                case SyntaxKind.SwitchStatement:\n                    return visitSwitchStatement(<SwitchStatement>node);\n\n                case SyntaxKind.CaseBlock:\n                    return visitCaseBlock(<CaseBlock>node);\n\n                case SyntaxKind.CaseClause:\n                    return visitCaseClause(<CaseClause>node);\n\n                case SyntaxKind.DefaultClause:\n                    return visitDefaultClause(<DefaultClause>node);\n\n                case SyntaxKind.TryStatement:\n                    return visitTryStatement(<TryStatement>node);\n\n                case SyntaxKind.CatchClause:\n                    return visitCatchClause(<CatchClause>node);\n\n                case SyntaxKind.Block:\n                    return visitBlock(<Block>node);\n\n                case SyntaxKind.MergeDeclarationMarker:\n                    return visitMergeDeclarationMarker(<MergeDeclarationMarker>node);\n\n                case SyntaxKind.EndOfDeclarationMarker:\n                    return visitEndOfDeclarationMarker(<EndOfDeclarationMarker>node);\n\n                default:\n                    return destructuringVisitor(node);\n            }\n        }\n\n        /**\n         * Visits the body of a ForStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForStatement(node: ForStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateFor(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.condition, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.incrementor, destructuringVisitor, isExpression, /*optional*/ true),\n                visitNode(node.statement, nestedElementVisitor, isStatement)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForInStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForInStatement(node: ForInStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForIn(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a ForOfStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitForOfStatement(node: ForOfStatement): VisitResult<Statement> {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateForOf(\n                node,\n                visitForInitializer(node.initializer),\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Determines whether to hoist the initializer of a ForStatement, ForInStatement, or\n         * ForOfStatement.\n         *\n         * @param node The node to test.\n         */\n        function shouldHoistForInitializer(node: ForInitializer): node is VariableDeclarationList {\n            return isVariableDeclarationList(node)\n                && shouldHoistVariableDeclarationList(node);\n        }\n\n        /**\n         * Visits the initializer of a ForStatement, ForInStatement, or ForOfStatement\n         *\n         * @param node The node to visit.\n         */\n        function visitForInitializer(node: ForInitializer): ForInitializer {\n            if (shouldHoistForInitializer(node)) {\n                let expressions: Expression[];\n                for (const variable of node.declarations) {\n                    expressions = append(expressions, transformInitializedVariable(variable, /*isExportedDeclaration*/ false));\n                }\n\n                return expressions ? inlineExpressions(expressions) : createOmittedExpression();\n            }\n            else {\n                return visitEachChild(node, nestedElementVisitor, context);\n            }\n        }\n\n        /**\n         * Visits the body of a DoStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDoStatement(node: DoStatement): VisitResult<Statement> {\n            return updateDo(\n                node,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock),\n                visitNode(node.expression, destructuringVisitor, isExpression)\n            );\n        }\n\n        /**\n         * Visits the body of a WhileStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWhileStatement(node: WhileStatement): VisitResult<Statement> {\n            return updateWhile(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a LabeledStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitLabeledStatement(node: LabeledStatement): VisitResult<Statement> {\n            return updateLabel(\n                node,\n                node.label,\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a WithStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitWithStatement(node: WithStatement): VisitResult<Statement> {\n            return updateWith(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.statement, nestedElementVisitor, isStatement, /*optional*/ false, liftToBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a SwitchStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitSwitchStatement(node: SwitchStatement): VisitResult<Statement> {\n            return updateSwitch(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNode(node.caseBlock, nestedElementVisitor, isCaseBlock)\n            );\n        }\n\n        /**\n         * Visits the body of a CaseBlock to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseBlock(node: CaseBlock): CaseBlock {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCaseBlock(\n                node,\n                visitNodes(node.clauses, nestedElementVisitor, isCaseOrDefaultClause)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a CaseClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCaseClause(node: CaseClause): VisitResult<CaseOrDefaultClause> {\n            return updateCaseClause(\n                node,\n                visitNode(node.expression, destructuringVisitor, isExpression),\n                visitNodes(node.statements, nestedElementVisitor, isStatement)\n            );\n        }\n\n        /**\n         * Visits the body of a DefaultClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitDefaultClause(node: DefaultClause): VisitResult<CaseOrDefaultClause> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a TryStatement to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitTryStatement(node: TryStatement): VisitResult<Statement> {\n            return visitEachChild(node, nestedElementVisitor, context);\n        }\n\n        /**\n         * Visits the body of a CatchClause to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitCatchClause(node: CatchClause): CatchClause {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = updateCatchClause(\n                node,\n                node.variableDeclaration,\n                visitNode(node.block, nestedElementVisitor, isBlock)\n            );\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        /**\n         * Visits the body of a Block to hoist declarations.\n         *\n         * @param node The node to visit.\n         */\n        function visitBlock(node: Block): Block {\n            const savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;\n            enclosingBlockScopedContainer = node;\n\n            node = visitEachChild(node, nestedElementVisitor, context);\n\n            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;\n            return node;\n        }\n\n        //\n        // Destructuring Assignment Visitors\n        //\n\n        /**\n         * Visit nodes to flatten destructuring assignments to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function destructuringVisitor(node: Node): VisitResult<Node> {\n            if (node.transformFlags & TransformFlags.DestructuringAssignment\n                && node.kind === SyntaxKind.BinaryExpression) {\n                return visitDestructuringAssignment(<DestructuringAssignment>node);\n            }\n            else if (node.transformFlags & TransformFlags.ContainsDestructuringAssignment) {\n                return visitEachChild(node, destructuringVisitor, context);\n            }\n            else {\n                return node;\n            }\n        }\n\n        /**\n         * Visits a DestructuringAssignment to flatten destructuring to exported symbols.\n         *\n         * @param node The node to visit.\n         */\n        function visitDestructuringAssignment(node: DestructuringAssignment): VisitResult<Expression> {\n            if (hasExportedReferenceInDestructuringTarget(node.left)) {\n                return flattenDestructuringAssignment(\n                    node,\n                    destructuringVisitor,\n                    context,\n                    FlattenLevel.All,\n                    /*needsValue*/ true\n                );\n            }\n\n            return visitEachChild(node, destructuringVisitor, context);\n        }\n\n        /**\n         * Determines whether the target of a destructuring assigment refers to an exported symbol.\n         *\n         * @param node The destructuring target.\n         */\n        function hasExportedReferenceInDestructuringTarget(node: Expression | ObjectLiteralElementLike): boolean {\n            if (isAssignmentExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.left);\n            }\n            else if (isSpreadExpression(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.expression);\n            }\n            else if (isObjectLiteralExpression(node)) {\n                return some(node.properties, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isArrayLiteralExpression(node)) {\n                return some(node.elements, hasExportedReferenceInDestructuringTarget);\n            }\n            else if (isShorthandPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.name);\n            }\n            else if (isPropertyAssignment(node)) {\n                return hasExportedReferenceInDestructuringTarget(node.initializer);\n            }\n            else if (isIdentifier(node)) {\n                const container = resolver.getReferencedExportContainer(node);\n                return container !== undefined && container.kind === SyntaxKind.SourceFile;\n            }\n            else {\n                return false;\n            }\n        }\n\n        //\n        // Modifier Visitors\n        //\n\n        /**\n         * Visit nodes to elide module-specific modifiers.\n         *\n         * @param node The node to visit.\n         */\n        function modifierVisitor(node: Node): VisitResult<Node> {\n            switch (node.kind) {\n                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.DefaultKeyword:\n                    return undefined;\n            }\n            return node;\n        }\n\n        //\n        // Emit Notification\n        //\n\n        /**\n         * Hook for node emit notifications.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node in the printer.\n         */\n        function onEmitNode(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void {\n            if (node.kind === SyntaxKind.SourceFile) {\n                const id = getOriginalNodeId(node);\n                currentSourceFile = <SourceFile>node;\n                moduleInfo = moduleInfoMap[id];\n                systemObject = exportFunctionsMap[id];\n                noSubstitution = noSubstitutionMap[id];\n\n                if (noSubstitution) {\n                    delete noSubstitutionMap[id];\n                }\n\n                previousOnEmitNode(hint, node, emitCallback);\n\n                currentSourceFile = undefined;\n                moduleInfo = undefined;\n                systemObject = undefined;\n                noSubstitution = undefined;\n            }\n            else {\n                previousOnEmitNode(hint, node, emitCallback);\n            }\n        }\n\n        //\n        // Substitutions\n        //\n\n        /**\n         * Hooks node substitutions.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        function onSubstituteNode(hint: EmitHint, node: Node) {\n            node = previousOnSubstituteNode(hint, node);\n            if (isSubstitutionPrevented(node)) {\n                return node;\n            }\n\n            if (hint === EmitHint.Expression) {\n                return substituteExpression(<Expression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitute the expression, if necessary.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpression(node: Expression) {\n            switch (node.kind) {\n                case SyntaxKind.Identifier:\n                    return substituteExpressionIdentifier(<Identifier>node);\n                case SyntaxKind.BinaryExpression:\n                    return substituteBinaryExpression(<BinaryExpression>node);\n                case SyntaxKind.PrefixUnaryExpression:\n                case SyntaxKind.PostfixUnaryExpression:\n                    return substituteUnaryExpression(<PrefixUnaryExpression | PostfixUnaryExpression>node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for an Identifier expression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteExpressionIdentifier(node: Identifier): Expression {\n            if (getEmitFlags(node) & EmitFlags.HelperName) {\n                return createPropertyAccess(createIdentifier(\"module\"), node);\n            }\n\n            // When we see an identifier in an expression position that\n            // points to an imported symbol, we should substitute a qualified\n            // reference to the imported symbol if one is needed.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            if (!isGeneratedIdentifier(node) && !isLocalName(node)) {\n                const importDeclaration = resolver.getReferencedImportDeclaration(node);\n                if (importDeclaration) {\n                    if (isImportClause(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent),\n                            createIdentifier(\"default\"),\n                            /*location*/ node\n                        );\n                    }\n                    else if (isImportSpecifier(importDeclaration)) {\n                        return createPropertyAccess(\n                            getGeneratedNameForNode(importDeclaration.parent.parent.parent),\n                            getSynthesizedClone(importDeclaration.propertyName || importDeclaration.name),\n                            /*location*/ node\n                        );\n                    }\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a BinaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteBinaryExpression(node: BinaryExpression): Expression {\n            // When we see an assignment expression whose left-hand side is an exported symbol,\n            // we should ensure all exports of that symbol are updated with the correct value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if (isAssignmentOperator(node.operatorToken.kind)\n                && isIdentifier(node.left)\n                && !isGeneratedIdentifier(node.left)\n                && !isLocalName(node.left)\n                && !isDeclarationNameOfEnumOrNamespace(node.left)) {\n                const exportedNames = getExports(node.left);\n                if (exportedNames) {\n                    // For each additional export of the declaration, apply an export assignment.\n                    let expression: Expression = node;\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Substitution for a UnaryExpression that may contain an imported or exported symbol.\n         *\n         * @param node The node to substitute.\n         */\n        function substituteUnaryExpression(node: PrefixUnaryExpression | PostfixUnaryExpression): Expression {\n            // When we see a prefix or postfix increment expression whose operand is an exported\n            // symbol, we should ensure all exports of that symbol are updated with the correct\n            // value.\n            //\n            // - We do not substitute generated identifiers for any reason.\n            // - We do not substitute identifiers tagged with the LocalName flag.\n            // - We do not substitute identifiers that were originally the name of an enum or\n            //   namespace due to how they are transformed in TypeScript.\n            // - We only substitute identifiers that are exported at the top level.\n            if ((node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken)\n                && isIdentifier(node.operand)\n                && !isGeneratedIdentifier(node.operand)\n                && !isLocalName(node.operand)\n                && !isDeclarationNameOfEnumOrNamespace(node.operand)) {\n                const exportedNames = getExports(node.operand);\n                if (exportedNames) {\n                    let expression: Expression = node.kind === SyntaxKind.PostfixUnaryExpression\n                        ? createPrefix(\n                            node.operator,\n                            node.operand,\n                            /*location*/ node)\n                        : node;\n\n                    for (const exportName of exportedNames) {\n                        expression = createExportExpression(exportName, preventSubstitution(expression));\n                    }\n\n                    if (node.kind === SyntaxKind.PostfixUnaryExpression) {\n                        expression = node.operator === SyntaxKind.PlusPlusToken\n                            ? createSubtract(preventSubstitution(expression), createLiteral(1))\n                            : createAdd(preventSubstitution(expression), createLiteral(1));\n                    }\n\n                    return expression;\n                }\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets the exports of a name.\n         *\n         * @param name The name.\n         */\n        function getExports(name: Identifier) {\n            let exportedNames: Identifier[];\n            if (!isGeneratedIdentifier(name)) {\n                const valueDeclaration = resolver.getReferencedImportDeclaration(name)\n                    || resolver.getReferencedValueDeclaration(name);\n\n                if (valueDeclaration) {\n                    const exportContainer = resolver.getReferencedExportContainer(name, /*prefixLocals*/ false);\n                    if (exportContainer && exportContainer.kind === SyntaxKind.SourceFile) {\n                        exportedNames = append(exportedNames, getDeclarationName(valueDeclaration));\n                    }\n\n                    exportedNames = addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[getOriginalNodeId(valueDeclaration)]);\n                }\n            }\n\n            return exportedNames;\n        }\n\n        /**\n         * Prevent substitution of a node for this transformer.\n         *\n         * @param node The node which should not be substituted.\n         */\n        function preventSubstitution<T extends Node>(node: T): T {\n            if (noSubstitution === undefined) noSubstitution = [];\n            noSubstitution[getNodeId(node)] = true;\n            return node;\n        }\n\n        /**\n         * Determines whether a node should not be substituted.\n         *\n         * @param node The node to test.\n         */\n        function isSubstitutionPrevented(node: Node) {\n            return noSubstitution && node.id && noSubstitution[node.id];\n        }\n    }\n}\n"
    },
    "filesToReloadContentFromDisk": []
  },
  "type": "request",
  "command": "ideChangeFiles"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideChangeFiles",
  "request_seq": 97,
  "success": true,
  "body": "done"
}
{
  "sessionId": 1486236505327,
  "seq": 98,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 98,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 99,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 99,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 100,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 100,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 101,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 101,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 102,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 102,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 103,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 103,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 104,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 104,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 105,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/system.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 105,
  "success": true,
  "body": {
    "infos": []
  }
}
{
  "sessionId": 1486236505327,
  "seq": 106,
  "arguments": {
    "files": [
      "/Users/Sergey/Work/GH/typescript/src/compiler/transformers/module/ecmal.ts"
    ]
  },
  "type": "request",
  "command": "ideGetErr"
}
{
  "seq": 0,
  "type": "response",
  "command": "ideGetErr",
  "request_seq": 106,
  "success": true,
  "body": {
    "infos": []
  }
}
